Розробник Python Нед Бетчелдер описує нотацію "О-велике" як метод аналізу, що визначає "**наскільки сповільниться код зі зростанням обсягу даних**" О-велике завжди описує **найгірший** варіант складності алгоритму.

> [!info] Інші позначення алгоритмічної складності
> Для оцінки найоптимістичнішого варіанту виконування алгоритму використовують **Омега-велике** (Ω-big). А позначення алгоритму, який  має однакову оцінку як і в кращому так і в гіршому випадках - Тета-велике (Θ-big).

Рівні складності алгоритмів:
- **O(1)**, постійний час (найнижчий порядок) інколи використовуються позначення **O(c).**
- **O(log n)**, логарифмічний час.
- **O(n)**, лінійний час.
- **O(n log n)**, час N-Log-N.
- **O(n<sup>2</sup>)**, поліноміальний час.
- **O(2<sup>n</sup>)**, експоненціальний час.
- **O(n!)**, факторіальний час (найвищий порядок).

> [!info] Переважно, складність алгоритмів сортування є **O(n log n)**

> [!info] `len(s)` - операція **O(1)**, тому що Python зберігає кількість елементів у послідовності чи словнику, щоб їх не доводилося заново перераховувати при кожному виклику `len()`.

> [!warning] Приведення списку до множини є операцією O(n), тож перетворення списку на множину для перевірки входження елементу до списку не дає ніякого виграшу.

[[Beyond the Basic Stuff with Python.pdf#page=271|Складність алгоритмів на прикладі книжної полички]]

[[Оффтоп]]