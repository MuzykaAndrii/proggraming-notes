### Коли використовувати декоратори
Будь-яка досить універсальна функціональність, яку можна прикріпити до наявного класу або поведінки функції не змінюючи її, є чудовим кандидатом для декорування. Сюди входять:
- ведення протоколу операцій (журналювання);
- забезпечення контролю за доступом і аутентифікацією;
- функції інструментального оформлення і хронометражу;
- обмеження частоти виклику API:
- кешування та ін.

- Декоратори дозволяють розширювати або змінювати поведінку декоруючих ними функцій, методів та класів без їх безпосередньої зміни.
- Декоратори по своїй природі являють собою функцію, яка приймає параметром іншу функцію та повертає її модифіковану версію.
- Модифікація відбувається додаванням перед та/або після виконання самої функції потрібного функціоналу, сама декорована функція викликається з допомогою замикання.
- Декоратори можуть бути додані одне за одним, функціонал буде виконуватись знизу вверх.

### Способи використання декораторів
Дві різні реалізації декораторів з однаковим результатом. Конструкція декораторів з `@` в python є **синтаксичним цукром** та тільки покращує читаємість коду.
```start-multi-column
ID: ID_5zo8
Number of Columns: 2
Largest Column: standard
```
```python
def uppercase(func):
	def wrapper():
		output = func().upper()
		return output
	return wrapper
	
	def some():
		return 'some text'
		
print(uppercase(some)())
# >> SOME TEXT
decorated_some = uppercase(some)  # (1)
print(decorated_some())
# >> SOME TEXT
```
--- column-end ---
```python
def uppercase(func):
	def wrapper():
		output = func().upper()
		return output
	return wrapper

@uppercase
def some():
	return 'some text'
	
print(some())  # >> SOME TEXT
```
=== end-multi-column

Спосіб **(2)** використовується тоді, коли декорована функція потрібна і в чистому (немодифікованому) вигляді, так як конструкція `@` змінює поведінку декорованої функції при кожному виклику.

### Метадані декорованих функцій
```python
import functools

def uppercase(func):
	@functools.wraps(func)
	def wrapper():
		return func().uppercase()
return wrapper
```
При виклику декорованої функції де-факто викликається функція-обгортка, відповідно усі мета дані (`__docstring__`, `__name__`, і тд.) будуть саме з функції-обгортки. Це може ускладнити процес відладки та пошуку багів. Щоб цьому запобігти функцію-обгортку треба декорувати встроєним декоратором `wrap` із модуля `functools`, який замінить усі метадані функції-обгортки на метадані функції яку обгортали.

[[Функції]]