Генератори це спеціальні [[Функції]], які зберігають свій стан після виконання.
```python
import collections, types
print(issubclass(types.GeneratorType, collections.Iterator))
# >> True
```
Генератори реалізують [[Протоколи|протокол]] [[Ітератори|ітераторів]].

```python
def bar(name: str):  # generator function
	for char in name:
		yield char

g = bar("bob")  # generator object
next(g)  # >> b
next(g)  # >> o
next(g)  # >> b
next(g)  # >> raises StopIteration
```
### Головні відмінності генераторних функцій від звичайних:
1. `yield` замість `return`
2. призупинення виконання, замість безповоротного повертання значення
3. Інструкцій `yield` може бути **декілька**

### Різниця між `return` та `yield`:
- Інструкція `return` безповоротно повертає потік виконання програми у місце, з якого вона викликана.
- Інструкція `yield` призупиняє виконання функції, зберігаючи її локальний стан (**зберігаючи фрейм функції**) та передає потік управління програмою у місце де її викликано. Виконання може бути відновлено в будь-який момент, використавши функцію `next()` із цим генератором.

### Використання генераторів:
- **Короткі функції-ітератори.**  В найпростішому випадку, генератори використовуються для коротких функцій-ітераторів, а ітератори використовуються коли потрібно додати ще якусь функціональність до цього **Iterable**-обєкта (додати методи чи поля до класу який реалізує протокол ітераторів).
- **Важкі обчислення частинами.** Генератори часто використовують у випадках, де потрібно виконати важку обробкку послідовності даних, де з кожним викликом `next()` обробляється лише її частина,  а не вся послідовність.
- **Асинхронність.** Можливість передавати управління програмою, зберігаючи свій локальний стан, дозволило використовуючи генераторні функції (**корутини**) створювати асинхронні програми.