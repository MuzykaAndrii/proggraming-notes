Існують ***прямі*** та ***обернені (віддзеркалені)*** оператори для реалізації числових [[Dunders|dunder-методів]]. При виклику наприклад операції `+`, Python спочатку викличе метод `__add__` в лівого операнда, і якщо він повертитиме `NotImplemented`, тоді викличе метод `__radd__` в правого операнда:
```python
class A:
	def __init__(self, value):
		self.value = value

	def __add__(self):
		return NotImplemented

class B:
	def __init__(self, value):
		self.value = value

	def __radd__(self, other):
		return B(self.value + other.value)

a = A(4)
b = B(5)

# 1. execute __add__ in class A, if returned NotImplemented, execute
# __radd__ in class B, if returned NotImplemented, return TypeError
print(a + b)  # >> 9
```

| Dunder-метод | Дзеркальний Dunder-метод  | Операція                 | Оператор або вбудована функція |
|-------------------------|---------------|--------------------------|-------------------------------|
| `__add__()`             | `__radd__()`  | Додавання                | `+`                           |
| `__sub__()`             | `__rsub__()`  | Віднімання               | `-`                           |
| `__mul__()`             | `__rmul__()`  | Множення                 | `*`                           |
| `__matmul__()`          | `__rmatmul__()` | Матричне множення        | `@` (в Python 3.5 і новіше)   |
| `__truediv__()`         | `__rtruediv__()` | Ділення                  | `/`                           |
| `__floordiv__()`        | `__rfloordiv__()` | Цілочисельне ділення     | `//`                          |
| `__mod__()`             | `__rmod__()`  | Остача                   | `%`                           |
| `__divmod__()`          | `__rdivmod__()` | Ділення з остачею        | `divmod()`                    |
| `__pow__()`             | `__rpow__()`  | Піднесення до степеня    | `**`, `pow()`                 |
| `__lshift__()`          | `__rlshift__()` | Зсув вліво               | `>>`                          |
| `__rshift__()`          | `__rrshift__()` | Зсув вправо              | `<<`                          |
| `__and__()`             | `__rand__()`  | Поразрядна операція AND | `&`                           |
| `__or__()`              | `__ror__()`   | Поразрядна операція OR  | `|`                           |
| `__xor__()`             | `__rxor__()`  | Поразрядна виключна операція OR | `^`                 |
| `__neg__()`            | -   | Від'ємне                 | Унарний `-`, як в -42          |
| `__pos__()`              |  -  | Тотожність               | Унарний `+`, як в +42          |
| `__abs__()`              |  -  | Абсолютне значення (модуль) | `abs()`                    |
| `__invert__()`             | -| Поразрядна інверсія      | `~`                           |
| `__complex__()`              |- | Комплексна форма числа   | `complex()`                   |
| `__int__()`         |  -  | Ціла форма числа         | `int()`                       |
| `__float__()`              | - | Форма числа з плаваючою точкою | `float()`                   |


##### Dunder-методи присвоєння на місці (in-place)
Числові та віддзеркалені dunder-методи завжди **створюють нові об'єкти** (замість зміни об'єктів на місці). Dunder-методи присвоювання на місці, що викликаються розширеними операторами присвоювання (такими як `+=` і `*=`), **змінюють об'єкт на місці** без створення нового об'єкта. Імена таких методів аналогічні числовим, але починаються з `i` (`__iadd__`, `__imul__` та ін.)

> [!important] Поведінка при відсутності in-place dunder'ів
> Якщо ви не реалізуєте in-place dunder-метод, Python викличе числовий dunder-метод. Наприклад, якщо в класі відсутній метод `__imul__()`, вираз `obj *= 10` викличе `__mul__()` і присвоїть значення, що повертається, об'єкту `obj`.
