GIL це механізм `CPython` який забезпечує потокобезпечність інтерпретатора та запобігає [[Конкурентність|умові гонки]]. GIL може обслуговувати тільки один потік програми на Python в кожен момент часу. Це означає, що тільки один потік може виконувати Python-код, і від числа процесорних ядер це не залежить.

Щоб перешкодити потоку Python утримувати GIL нескінченно, інтерпретатор байт-коду Python періодично (за замовчуванням раз на 5 мілісекунд) призупиняє поточний потік і тим самим звільняє GIL. Потік може спробувати знову захопити GIL, але якщо на нього чекають інші потоки, то планувальник ОС, можливо, вибере один із них.

Так як GIL в любому випадку обслуговує тільки один потік, лінійні програми будуть виконуватись швидше, тому що ОС **тратить додаткові ресурси для переключення контексту** потоків. Винятком є дії вводу-виводу (**I/O**), та скрипти на С, які уже в себе в тілі розкривають декілька потоків для виконання **CPU-bound** обчислень.

> [!important] Розробник не може ніяк впливати на роботу GIL. 
Будь-яка стандартна бібліотечна функція Python, що робить системний виклик, звільняє GIL. Сюди належать усі функції, що виконують дискове введення-виведення, мережеве введення-виведення, а також `time.sleep()`. Багато лічильних функцій у бібліотеках `NumPy`/`SciPy`, а також функції стиснення і розпакування з модулів `zlib` і `bz2` також звільняють GIL. Деякі важкі обчислення написані на чистому C і бібліотека `hashlib` теж звільняють GIL.

> [!info] GIL в back-end розробці.
Так як мережеве введення-виведення звільняє GIL, та є однозначно повільнішим чим введення-виведення в власну пам'ять, програмування мережевих застосунків на Python в мультипотоковому режимі практично не залежить від GIL.

###### Чому GIL не можна видалити/вимкнути
Першим фактором в важливості роботи GIL є робота [[Garbage collector|збиральника мусору]]. Так як збиральник мусору перевіряє поле `refference_count` в об'єктах Python, в [[Конкурентність|умовах гонки]] це поле може бути модифіковане (інкремент чи декремент) одночасно декількома процесами, тобто процеси перебуватимуть в умові гонки. GIL запобігає такій ситуації.
Другий фактор - GIL спрощує написання розширень на C. Розробники можуть припустити, що тільки один потік запускає їхнє розширення C у будь-який момент часу. Таким чином, їм не потрібно використовувати додаткове блокування, щоб зробити код потокобезпечним. Коли вони захочуть запустити код паралельно, вони можуть відпустити GIL.