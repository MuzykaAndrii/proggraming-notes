
## Компактність
Класи як і функції мають бути компактними. У випадку з класами компактність вимірюється зонами відповідальності, а не рядками. Якщо клас має багато методів для різного функціоналу - він не компактний, і **порушує принцип єдиної відповідальності**.

## Принцип єдиної відповідальності (SRP)
**Клас або модуль, повинен мати одну, і тільки одну причину для зміни**. Тобто, причина для зміни класу слугує критерієм для оцінювання розміру класу та визначенням **відповідальності**.

> [!info] Імя класу як показник відповідальності
> Імя класу повинне описувати його відповідальності. Якщо для класу важко підібрати чітке і конкретне імя, він імовірно порушує SRP.

> [!info] Опис класу як показник відповідальнності
> Короткий опис класу має вміщатись приблизно в 25 слів, та **не повинен містити вирази: "якщо", "і", "або", "але"**. Ці слова-маркери свідчать що клас має занадто багато відповідальностей.

> [!info] Групування методів/атрибутів як показник порушення SRP
> Якщо у класі є атрибути чи методи, які можна згрупувати та які легко звязані із іншими атрибутами/методами це свідчить про множинну відповідальність та декілька причин для зміни.

## Принцип відкритості/закритості (OCP)
Всі програмні системи перебувають у процесі безперервних змін. Кожна зміна створює ризик що інші частини системи працюватимуть не так як ми очікуємо. Щоб зменшити ці ризики **класи повинні бути відкриті для розширення та закриті для модифікації (змін)**.

```python
class SqlGenerator:
	def select(): ...
	def insert(): ...
	def select_one(): ...
	def insert_many(): ...
	def delete(): ...
```

Тут принцип відкритості/закритості порушений тому що для розширення нового функціоналу (наприклад додавання update) нам прийдеться змінювати наявний клас.

Окрім того, клас порушує SRP тому що:
- методи `insert` та `insert_many`, `select` та `select_many` можна згрупувати.
- якщо потрібно змінити логіку для вибірки чи видалення це свідчить про множинну відповідальність

```python
class Sql(ABS):
	@abstractmethod
	def generate(): pass

class Insert(Sql):
	def generate(): ...
	
class Update(Sql): ...
	def generate(): ...
	
class Delete(Sql): ...
	def generate(): ...
```

Тут клас `Sql`:
- відкритий для розширення (можна створювати підкласи для додавання функціоналу)
- закритий для змін (при внесенні нового функціоналу інші класи змінювати не треба)

Тепер окрему логіку для множиннного вставлення/вибірки можна винести до спеціалізованого класу.
Крім того ми розділили відповідальність на менші класи згідно SRP. 

> [!important] Розширювати неможна змінювати
> Структура системи має бути такою, щоб внесення змін створювало якнайменше проблем. **В ідеалі нова функціональність повинна реалізовуватися через розширення системи, а не внесення в неї змін**.


## Принцип обернення залежностей

Класи в системі, повинні залежати не від один одного (конкретних реалізацій), а від абстракцій. Таким чином їхня звязність зменшується.

```python
class ChatGPT:
	def ask(self, prompt):
		return requests.get("https://gpt.com", prompt=prompt, key=self.key)

class TextGenerator:
	def __init__(self, provider: ChatGPT):  # depends to strict implementation
		self.provider = provider
		
	def from_keywords(self, kwds: list):
		return self.provider.ask(f"Make sentence with words: {", ".join(kwds)}")
```
 В цьому випадкуу клаc `TextGenerator` строго залежить від деталей реалізації класу `ChatGPT`. Через це виникнуть наступні проблеми:
 - Ми не зможемо протестувати `TextGenerator` так як нейромережа повертатиме щоразу іншу відповідь
 - Якщо ми вирішимо перейти на іншого провайдера (наприклад `Copilot`), тоді нам прийдеться змінювати його тип в конструкторі `TextGenerator`, або переписувати клас `ChatGPT` (що порушує OCP).

```python
class GPTInterface(ABS):
	@abstractmethod
	def ask(self, prompt: str) -> str:
		pass

class ChatGPT(GPTInterface): ...

class Copilot(GPTInterface): ...

class TextGenerator:
	def __init__(self, provider: GPTInterface): # depends to abstraction
		self.provider = provider

	def from_keywords(self, kwds: list):
		return self.provider.ask(f"Make sentence with words: {", ".join(kwds)}")
```

Тут клас `TextGenerator` залежить від абстракції `GPTInterface`. Згідно до інтерфейсу, клас, переданий у аргумент `provider`, має метод `ask` яким і користується `TextGenerator`, таким чином ми позбавляємось залежності ввід конкретної реалізації і ізолюємо класи одне від одного. Також в такому випадку можливе тестування:

```python
class MockGPT(GPTInterface): # mock class for testing
	def ask(self, prompt):
		return "AI chats are awesome!"

def test_from_keywords():
	tg = TextGenerator(MockGpt())
	assert tg.from_keywords(["ai", "chat"]) == "AI chats are awesome!"
```

> [!warning] DIP в динамічно типізованих мовах
> Принцип обернення залежностей дозволює більш гнучко визначати типи даних які приймає конструктор класу. В динамічно типізованих мовах на місце аргументу з очікуваним типом, наприклад `int` може бути переданий рядок чи бідь який інший тип, тому приклад із неможливістю тестування чи заміни провайдера для динамічних мов тут не можна застосувати. Але:
> 
> **Головна перевага DIP полягає у побудові більш модульних та менш звязних  систем, тому є актуальним і в динамічних мовах програмування**