- Ключі словників повинні бути унікальними значеннями.
	- - Де-юре ключі словників можуть бути тільки незмінюваними (**immutable**) типами даних.
	- Де-факто ключами можуть бути будь-які об'єкти, які мають реалізований дандер `__hash__`.
- Словники є типом даних із швидким доступом до елементів зі часовою складністю **O(1)**.
- Під капотом, атрибути класів зберігаються в словниках
- Для розпаковки словників треба використовувати метод `items()`, для отримання тільки значень – `values()`, по замовчуванню (без методу) перебір відбувається по ключам (метод `keys()`)

Метод `get()` повертає `None` якщо ключа немає в словнику (квадратні дужки викликають `IndexError`), але якщо параметром в метод `get()` передати деяке значення, то при не знаходженні ключа метод поверне те значення.

`dict.fromkeys(keys, values)` - фабрика класу `dict` яка приймає послідовність і робить їх ключами, та послідовність (або єдине значення для всіх) значень.
```python
keys = ('keys', 'key2', 'key3")
values_or_value = 0

some_dict = dict. fromkeys(keys, values_or _value)
print(some_dict)  # >> ('key': 0, 'key2': 0, 'Кеу3': 0}
```

## Особливості ключів
```python
print({True: 'yes', 1: 'no', 1.0: 'maybe'})
# >> {True: 'maybe'}
```
Така поведінка обумовлена тим, що значення **1.0**, **1** та **True** є еквівалентними (python всіх їх інтерпретує як **1**), тому насправді зліва направо відбувається перезаписування значення (yes -> no -> maybe). Ключ словника залишився першим (**True**), так як при присвоєнні відбувається не перезаписування ключа, а **порівняння хеш-значень ключів**, і так як всі ключі інтерпретуються як 1, то і їх хеш-значення будуть рівними.

## Обєднання словників

```python
xs = {'a': 1, 'b': 2}
ys = {'b': 3, 'c': 4}

zs = dict()
zs.update(xs)
zs.update(ys)
# >> zs = {'c': 4, 'a': 1, 'b': 3}

zs = dict(xs, **ys)
# >> zs = {'a': 1, 'c': 4, 'b': 3}

zs = {**xs, **ys}  # from python 3.5+
# >> zs = {'c': 4, 'a': 1, 'b': 3}
```

[[Container (контейнери)]]